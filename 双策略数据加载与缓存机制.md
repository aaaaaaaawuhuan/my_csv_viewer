# 双策略数据加载与缓存机制

## 开发步骤

### 1. 准备工作
1. 确保理解当前项目架构：
   - MainWindow: 主窗口控制器
   - TableModel: 数据模型
   - CSVReader: CSV文件读取器
   - 外部滚动条控制整体滚动

2. 熟悉当前代码实现：
   - 查看mainwindow.h/cpp了解现有滚动处理逻辑
   - 查看tablemodel.h/cpp了解数据模型实现
   - 查看csvreader.h/cpp了解数据读取实现

### 2. 实现双倍窗口TableModel
1. 修改TableModel类，扩展数据存储能力
2. 添加完整数据存储和可视窗口控制机制
3. 实现数据窗口调整方法

### 3. 修改MainWindow滚动处理逻辑
1. 调整滚动阈值判断逻辑
2. 实现小范围滚动时的数据窗口调整
3. 实现大范围滚动时的数据加载

### 4. 实现缓存管理机制
1. 设计缓存数据结构
2. 实现缓存预加载机制
3. 实现缓存淘汰策略

### 5. 优化用户体验
1. 添加状态栏实时反馈
2. 添加滚动条视觉状态提示
3. 优化加载过程中的用户提示

### 6. 测试验证
1. 测试小范围滚动响应性
2. 测试大范围滚动正确性
3. 测试边界情况处理
4. 验证内存使用情况

## 完整方案：双策略数据加载与缓存机制

### 0. 控件设计

#### 0.1 界面布局设计
根据项目当前的UI结构，界面布局应如下设计：
```xml
<!-- MainWindow.ui 中的布局结构 -->
<QWidget class="centralwidget">
  <layout class="QHBoxLayout">
    <item>
      <!-- 将滚动条移到frame内部 -->
      <widget class="QFrame">
        <layout class="QGridLayout">
          <item row="0" column="0">
            <widget class="QTableView" name="tableView"/>
          </item>
          <item row="0" column="1">
            <!-- 垂直滚动条在frame内部，与tableView并列 -->
            <widget class="QScrollBar" name="verticalScrollBar">
              <property name="orientation">
                <enum>Qt::Vertical</enum>
              </property>
            </widget>
          </item>
        </layout>
      </widget>
    </item>
  </layout>
</widget>
```

#### 0.2 控件交互设计
- 主窗口滚动条（ui->verticalScrollBar）作为唯一滚动控制组件
- TableView自身的滚动条已禁用（Qt::ScrollBarAlwaysOff）
- 滚动条范围：0 到 (总行数 - 可视行数)
- 滚动条值变化时触发延迟加载机制

#### 0.3 控件视图和控件滚动条的关联做法

为了确保控件视图和控件滚动条正确关联，需要实现以下机制：

1. **滚动条范围设置**：
```cpp
void MainWindow::updateScrollBarRange() {
    // 设置滚动条范围
    ui->verticalScrollBar->setRange(0, m_totalRows - m_visibleRows);
    ui->verticalScrollBar->setPageStep(m_visibleRows);
    
    // 同步TableView的滚动位置
    QScrollBar* tableViewVScroll = ui->tableView->verticalScrollBar();
    if (tableViewVScroll) {
        // 禁用TableView的垂直滚动条
        ui->tableView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    }
}
```

2. **滚动条与TableView同步**：
```cpp
// 当用户操作外部滚动条时
void MainWindow::onVerticalScrollBarValueChanged(int value) {
    // 防止信号循环调用
    if (m_internalScrollBarChange) 
        return;
        
    m_internalScrollBarChange = true;
    
    // 启动延迟加载
    m_delayedLoadTimer->start(200);
    
    m_internalScrollBarChange = false;
}
```

3. **防止信号循环调用**：
使用[m_internalScrollBarChange](file://c:\Users\910093\Desktop\Miscellaneous_Issues\my_csv_viewer\mainwindow.h#L29-L29)标志位防止滚动条和TableView之间的信号循环调用

### 1. 设计思路

我们需要实现一个智能的数据加载和缓存系统，包含以下特性：

1. **双策略加载**：
   - 大范围滚动：重新加载目标位置数据及前后缓存
   - 小范围滚动：使用缓存数据或调整数据窗口

2. **三层缓存窗口**：
   - 前置预加载区域
   - 当前显示区域
   - 后置预加载区域

3. **智能预加载**：
   - 根据滚动方向预加载数据
   - 后台线程执行预加载任务

### 2. 核心数据结构

```cpp
// 缓存数据块
struct DataBlock {
    QVector<QStringList> data;  // 实际数据
    qint64 startRow;            // 起始行号
    qint64 endRow;              // 结束行号
    bool isValid;               // 是否有效
    QDateTime timestamp;        // 时间戳（用于LRU）
};

// 缓存管理器
class DataCacheManager {
    DataBlock currentBlock;     // 当前显示块
    DataBlock preBlock;         // 前置预加载块
    DataBlock postBlock;        // 后置预加载块
    qint64 m_totalRows;         // 总行数
    qint64 m_blockSize;         // 块大小（可视行数）
    
public:
    // 根据当前项目设置，m_blockSize应与MainWindow::m_visibleRows保持一致
    // 默认值可以设置为100行
};
```

### 3. 滚动策略识别

在当前项目中，滚动策略识别应该基于MainWindow中的滚动事件处理：

```cpp
// 在MainWindow类中添加滚动策略识别逻辑
enum ScrollType {
    SMALL_SCROLL,   // 小范围滚动
    LARGE_SCROLL    // 大范围滚动
};

ScrollType MainWindow::detectScrollType(qint64 oldPosition, qint64 newPosition) {
    // 根据滚动距离判断是大范围还是小范围滚动
    qint64 distance = qAbs(newPosition - oldPosition);
    
    // 如果滚动距离超过可视区域的一半，则认为是大范围滚动
    // 否则为小范围滚动
    if (distance > m_visibleRows / 2) {
        return LARGE_SCROLL;
    } else {
        return SMALL_SCROLL;
    }
}
```

### 4. 数据加载策略

#### 4.1 大范围滚动处理

当检测到大范围滚动时，需要重新加载数据：

```cpp
void MainWindow::handleLargeScroll(qint64 targetPosition) {
    // 1. 清除当前显示的数据，但保留表头
    // 注意：只清空数据，不清空表头
    m_tableModel->clearDataOnly(); // 新增方法，只清空数据部分
    
    // 2. 计算需要加载的数据范围
    qint64 startRow = targetPosition;
    qint64 rowCount = m_visibleRows * 3; // 加载3倍数据以支持小范围滚动
    
    // 3. 请求数据加载
    emit requestRowsData(startRow + 1, rowCount); // +1跳过表头
    
    // 4. 更新当前起始行
    m_currentStartRow = targetPosition;
    
    // 5. 启动预加载（无论大范围还是小范围都应该及时启动预加载）
    preloadData(targetPosition + m_visibleRows / 2);
}
```

#### 4.2 小范围滚动处理

对于小范围滚动，我们使用双倍窗口机制：

```cpp
void MainWindow::handleSmallScroll(qint64 targetPosition) {
    // 小范围滚动时，调整TableModel中的可视窗口
    qint64 relativePosition = targetPosition - m_tableModel->getFullDataStartRow();
    
    // 检查目标位置是否在当前Model数据范围内
    if (relativePosition >= 0 && 
        relativePosition + m_visibleRows <= m_tableModel->getFullDataSize()) {
        // 在范围内，只需调整可视窗口
        m_tableModel->adjustVisibleWindow(relativePosition);
        
        // 更新当前起始行
        m_currentStartRow = targetPosition;
    } else {
        // 超出范围，需要加载新数据（降级到大范围滚动处理）
        handleLargeScroll(targetPosition);
    }
    
    // 启动预加载（无论大范围还是小范围都应该及时启动预加载）
    preloadData(targetPosition + m_visibleRows / 2);
}
```

### 5. 预加载机制

#### 5.1 预加载策略

```cpp
void MainWindow::preloadData(qint64 centerRow) {
    // 预加载前置块
    qint64 preStart = qMax(0LL, centerRow - m_visibleRows);
    qint64 preEnd = preStart + m_visibleRows - 1;
    if (preStart <= preEnd) {
        requestPreload(preStart, preEnd - preStart + 1, PRE_BLOCK);
    }
    
    // 预加载后置块
    qint64 postStart = centerRow + m_visibleRows;
    qint64 postEnd = qMin(m_totalRows - 1, postStart + m_visibleRows - 1);
    if (postStart <= postEnd) {
        requestPreload(postStart, postEnd - postStart + 1, POST_BLOCK);
    }
}
```

#### 5.2 后台预加载

使用低优先级线程或任务队列执行预加载：

```cpp
void MainWindow::requestPreload(qint64 startRow, qint64 rowCount, CachePosition position) {
    // 将预加载任务添加到队列
    PreloadTask task;
    task.startRow = startRow;
    task.rowCount = rowCount;
    task.position = position;
    task.priority = LOW_PRIORITY;
    
    // 添加到预加载队列
    m_preloadQueue.enqueue(task);
    
    // 如果预加载线程空闲，启动预加载
    if (!m_preloadThread.isRunning()) {
        startPreloadThread();
    }
}
```

### 6. 缓存管理

#### 6.1 缓存更新

```cpp
void MainWindow::updateCache(const DataBlock& newBlock, CachePosition position) {
    switch(position) {
    case CURRENT_BLOCK:
        m_cache.currentBlock = newBlock;
        break;
    case PRE_BLOCK:
        m_cache.preBlock = newBlock;
        break;
    case POST_BLOCK:
        m_cache.postBlock = newBlock;
        break;
    }
    
    // 更新时间戳用于LRU
    newBlock.timestamp = QDateTime::currentDateTime();
}
```

#### 6.2 缓存淘汰

```cpp
void MainWindow::evictOldCache() {
    // 简单的LRU实现：保留最新的缓存块
    QDateTime oldest = QDateTime::currentDateTime();
    CachePosition oldestPos = CURRENT_BLOCK;
    
    if (m_cache.preBlock.timestamp < oldest) {
        oldest = m_cache.preBlock.timestamp;
        oldestPos = PRE_BLOCK;
    }
    
    if (m_cache.postBlock.timestamp < oldest) {
        oldestPos = POST_BLOCK;
    }
    
    // 淘汰最旧的缓存
    switch(oldestPos) {
    case PRE_BLOCK:
        m_cache.preBlock.isValid = false;
        break;
    case POST_BLOCK:
        m_cache.postBlock.isValid = false;
        break;
    }
}
```

### 7. 内存优化

#### 7.1 内存限制

```cpp
void MainWindow::checkMemoryUsage() {
    // 估算当前缓存内存使用量
    qint64 memoryUsage = calculateCacheMemoryUsage();
    
    // 如果超过限制，执行缓存淘汰
    if (memoryUsage > MAX_CACHE_MEMORY) {
        evictOldCache();
    }
}
```

#### 7.2 智能清理

```cpp
void MainWindow::cleanupCache(qint64 currentRow) {
    // 清理距离当前位置过远的缓存
    qint64 distanceThreshold = m_visibleRows * 3; // 3个块的距离
    
    if (qAbs(m_cache.preBlock.startRow - currentRow) > distanceThreshold) {
        m_cache.preBlock.isValid = false;
    }
    
    if (qAbs(m_cache.postBlock.startRow - currentRow) > distanceThreshold) {
        m_cache.postBlock.isValid = false;
    }
}
```

### 8. Model与TableView的对应关系

#### 8.1 双倍窗口TableModel设计

为了支持双倍窗口机制，我们需要改进TableModel：

```cpp
// 改进后的TableModel设计
class EnhancedTableModel : public QAbstractTableModel {
    QVector<QString> m_headers;              // 表头数据
    QVector<QStringList> m_fullData;         // 存储3倍于可视区域的数据
    qint64 m_fullDataStartRow;               // fullData在文件中的起始行号
    qint64 m_visibleStartRow;                // 可视区域在fullData中的起始行号
    qint64 m_visibleRows;                    // 可视区域行数
    
public:
    // 设置完整数据集（3倍大小）
    void setFullData(const QVector<QStringList> &data, qint64 startRow) {
        beginResetModel();
        m_fullData = data;
        m_fullDataStartRow = startRow;
        // 默认可视区域从完整数据的开头开始
        m_visibleStartRow = 0;
        // 假设传入的data大小就是3倍的可视行数
        m_visibleRows = data.size() / 3;
        endResetModel();
    }
    
    // 调整可视窗口（小范围滚动时使用）
    void adjustVisibleWindow(qint64 relativeStartRow) {
        if (relativeStartRow >= 0 && 
            relativeStartRow + m_visibleRows <= m_fullData.size()) {
            m_visibleStartRow = relativeStartRow;
            // 只需要通知视图更新，不需要重置整个模型
            emit dataChanged(
                index(0, 0), 
                index(m_visibleRows - 1, columnCount() - 1)
            );
        }
    }
    
    // 获取完整数据的起始行号
    qint64 getFullDataStartRow() const {
        return m_fullDataStartRow;
    }
    
    // 获取完整数据的大小
    int getFullDataSize() const {
        return m_fullData.size();
    }
    
    // 其他TableModel必要的实现...
    int rowCount(const QModelIndex &parent = QModelIndex()) const override {
        if (parent.isValid())
            return 0;
        return m_visibleRows; // 只返回可视区域的行数
    }
    
    int columnCount(const QModelIndex &parent = QModelIndex()) const override {
        if (parent.isValid())
            return 0;
        return m_headers.size();
    }
    
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override {
        if (!index.isValid() || index.row() >= m_visibleRows || index.column() >= m_headers.size())
            return QVariant();
        
        // 计算在完整数据中的实际行号
        int actualRow = m_visibleStartRow + index.row();
        if (actualRow >= m_fullData.size())
            return QVariant();
        
        const QStringList& rowData = m_fullData.at(actualRow);
        if (index.column() >= rowData.size()) {
            return QVariant();
        }
        
        if (role == Qt::DisplayRole) {
            return rowData.at(index.column());
        }
        
        return QVariant();
    }
    
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override {
        if (role == Qt::DisplayRole) {
            if (orientation == Qt::Horizontal && section < m_headers.size()) {
                return m_headers.at(section);
            } else if (orientation == Qt::Vertical) {
                // 显示实际的行号
                return QString::number(m_fullDataStartRow + m_visibleStartRow + section + 1);
            }
        }
        
        return QAbstractTableModel::headerData(section, orientation, role);
    }
};
```

#### 8.2 垂直表头行号显示

```cpp
// 在TableModel::headerData中正确显示行号
QVariant EnhancedTableModel::headerData(int section, Qt::Orientation orientation, int role) const {
    if (role == Qt::DisplayRole) {
        if (orientation == Qt::Horizontal && section < m_headers.size()) {
            return m_headers.at(section);
        } else if (orientation == Qt::Vertical) {
            // 显示实际的行号
            return QString::number(m_fullDataStartRow + m_visibleStartRow + section + 1);
        }
    }
    
    return QAbstractTableModel::headerData(section, orientation, role);
}
```

### 9. 用户体验优化

#### 9.1 流畅滚动

- 使用缓存数据时，立即更新界面，无延迟
- 预加载机制减少用户等待时间
- 智能预测用户滚动方向，提前加载相应数据

#### 9.2 视觉反馈

```cpp
void MainWindow::showLoadingIndicator(bool show) {
    if (show) {
        // 显示加载指示器
        statusBar()->showMessage("正在加载数据...");
    } else {
        // 隐藏加载指示器
        QString positionInfo = QString("显示行 %1-%2 (共%3行)")
            .arg(m_currentStartRow + 1)
            .arg(m_currentStartRow + m_tableModel->rowCount())
            .arg(m_totalRows);
        statusBar()->showMessage(positionInfo);
    }
}

void MainWindow::onVerticalScrollBarValueChanged(int value) {
    // 立即提供视觉反馈
    QString positionMsg = QString("位置: 第%1行 (当前显示%2-%3行)")
        .arg(value + 1)
        .arg(m_currentStartRow + 1)
        .arg(m_currentStartRow + m_visibleRows);
    statusBar()->showMessage(positionMsg);
    
    // 改变滚动条颜色表示"处理中"
    QPalette pal = ui->verticalScrollBar->palette();
    pal.setColor(QPalette::Active, QPalette::Highlight, QColor(255, 255, 0, 128)); // 半透明黄色
    ui->verticalScrollBar->setPalette(pal);
    
    // 启动延迟加载
    m_delayedLoadTimer->start(200);
}

void MainWindow::onDelayedLoad() {
    // 恢复正常样式
    ui->verticalScrollBar->setPalette(QPalette());
    
    // 原有处理逻辑...
    int currentValue = ui->verticalScrollBar->value();
    ScrollType scrollType = detectScrollType(m_lastScrollPosition, currentValue);
    
    if (scrollType == LARGE_SCROLL) {
        handleLargeScroll(currentValue);
    } else {
        handleSmallScroll(currentValue);
    }
    
    m_lastScrollPosition = currentValue;
}
```

### 10. 实现要点

1. **滚动类型识别**：通过滚动距离和时间间隔判断
2. **缓存管理**：实现高效的缓存存储和检索机制
3. **预加载机制**：后台预加载可能需要的数据
4. **内存控制**：限制缓存大小，防止内存占用过高
5. **线程安全**：确保缓存访问的线程安全性
6. **LRU策略**：合理淘汰旧缓存数据
7. **智能预测**：根据滚动方向预测用户需求

### 11. 与现有架构的集成

基于当前项目架构，需要进行以下修改：

1. **在MainWindow类中添加缓存管理器**：
   ```cpp
   // 在MainWindow.h中添加
   private:
       DataCacheManager m_cacheManager;  // 缓存管理器
       qint64 m_lastScrollPosition;      // 上次滚动位置
       bool m_internalScrollBarChange;   // 防止滚动条信号循环调用
   ```

2. **修改滚动条处理逻辑**：
   ```cpp
   // 在onVerticalScrollBarValueChanged中实现双策略处理
   void MainWindow::onVerticalScrollBarValueChanged(int value) {
       // 防止信号循环调用
       if (m_internalScrollBarChange) 
           return;
           
       // 立即提供视觉反馈
       QString positionMsg = QString("位置: 第%1行 (当前显示%2-%3行)")
           .arg(value + 1)
           .arg(m_currentStartRow + 1)
           .arg(m_currentStartRow + m_visibleRows);
       statusBar()->showMessage(positionMsg);
       
       // 改变滚动条颜色表示"处理中"
       QPalette pal = ui->verticalScrollBar->palette();
       pal.setColor(QPalette::Active, QPalette::Highlight, QColor(255, 255, 0, 128));
       ui->verticalScrollBar->setPalette(pal);
       
       m_internalScrollBarChange = true;
       
       // 启动延迟加载
       m_delayedLoadTimer->start(200);
       
       m_internalScrollBarChange = false;
   }
   ```

3. **优化数据接收处理**：
   ```cpp
   // 在onRowsDataReceived中添加缓存更新逻辑
   void MainWindow::onRowsDataReceived(const struct CsvRowData &rowData, qint64 startRow) {
       // 恢复滚动条正常样式
       ui->verticalScrollBar->setPalette(QPalette());
       
       // 更新缓存
       updateCacheWithReceivedData(rowData, startRow);
       
       // 更新UI显示（使用增强的TableModel）
       m_tableModel->setFullData(rowData.rows, startRow);
       
       // 更新状态栏
       updateStatusBarWithPositionInfo(startRow, rowData.rows.size() / 3);
   }
   ```

### 12. 性能优势

这个方案能带来以下性能优势：

1. **响应速度**：小范围滚动时直接调整数据窗口，几乎无延迟
2. **用户体验**：所有滚动操作都有即时反馈，预加载机制让用户感觉数据加载更快
3. **资源利用**：合理使用内存缓存，避免重复加载
4. **内存控制**：通过缓存管理和淘汰机制控制内存使用
5. **并发处理**：后台预加载不阻塞主线程

### 13. 扩展性考虑

1. **可配置参数**：
   - 缓存块大小（与可视行数关联）
   - 预加载策略
   - 内存限制

2. **高级特性**：
   - 根据用户行为调整预加载策略
   - 支持磁盘缓存以处理超大数据集
   - 自适应块大小调整

3. **与现有功能的兼容性**：
   - 保持现有的异步加载机制
   - 兼容现有的性能监控功能
   - 不影响筛选面板等其他功能

这个方案能够很好地平衡性能、内存使用和用户体验，为用户提供流畅的大型CSV文件浏览体验。