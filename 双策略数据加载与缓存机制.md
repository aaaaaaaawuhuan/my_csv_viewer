# 双策略数据加载与缓存机制

## 需求分析

### 用户行为特点
1. 用户拖动滚动条寻找目标数据时会频繁拖动
2. 找到大致范围后会停止拖动
3. 停止拖动后开始使用鼠标滚轮精确滚动浏览
4. 用户期望快速响应拖动操作，同时在停止后能流畅滚动

### 性能要求
1. 拖动过程中仅加载当前显示部分数据，减少不必要的IO操作
2. 拖动停止后预加载上下部分数据，提升后续浏览体验
3. 合理使用内存缓存，避免占用过多资源
4. 提供流畅的用户体验，减少等待时间

## 设计思路

### 三层数据加载策略
1. **即时加载策略**：
   - 用户拖动滚动条时立即触发
   - 仅加载当前可视区域数据
   - 快速响应，低延迟

2. **预加载策略**：
   - 用户停止拖动滚动条后触发
   - 加载当前可视区域及前后缓冲区域数据
   - 提升后续浏览流畅度

3. **智能缓存策略**：
   - 缓存最近访问的数据块
   - 根据访问频率和时间进行淘汰
   - 平衡内存使用和性能

### 数据结构设计

```
// 缓存数据块
struct DataBlock {
    QVector<QStringList> data;  // 实际数据
    qint64 startRow;            // 起始行号
    qint64 endRow;              // 结束行号
    bool isValid;               // 是否有效
    QDateTime timestamp;        // 时间戳（用于LRU）
    int accessCount;            // 访问次数（用于LFU）
};

// 缓存管理器
class DataCacheManager {
    QList<DataBlock> cacheBlocks;  // 缓存块列表
    qint64 m_totalRows;            // 总行数
    qint64 m_visibleRows;          // 可视行数
    qint64 m_bufferRows;           // 缓冲行数（预加载区域）
    qint64 m_maxMemoryUsage;       // 最大内存使用量
    
public:
    // 根据当前项目设置，m_visibleRows应与MainWindow::m_visibleRows保持一致
    // m_bufferRows建议设置为m_visibleRows的1-2倍
    // m_maxMemoryUsage根据系统资源动态调整
};
```

## 核心实现

### 1. 滚动条拖动检测
```cpp
// 在MainWindow类中添加滚动状态检测
class MainWindow {
private:
    QTimer* m_scrollStopTimer;     // 滚动停止检测定时器
    bool m_isScrolling;           // 是否正在滚动
    qint64 m_lastScrollValue;     // 上次滚动值
    static const int SCROLL_STOP_DELAY = 300; // 滚动停止判定延迟(ms)
    
public slots:
    void onVerticalScrollBarValueChanged(int value);
    void onScrollStopped();       // 滚动停止处理
};
```

### 2. 双阶段数据加载

#### 2.1 即时加载（拖动过程中）
```cpp
void MainWindow::onVerticalScrollBarValueChanged(int value) {
    // 立即更新滚动状态
    m_isScrolling = true;
    m_lastScrollValue = value;
    
    // 重启滚动停止检测定时器
    m_scrollStopTimer->start(SCROLL_STOP_DELAY);
    
    // 即时加载当前可视区域数据
    loadVisibleData(value);
}

void MainWindow::loadVisibleData(qint64 startRow) {
    // 计算需要加载的数据范围（仅当前可视区域）
    qint64 rowCount = m_visibleRows;
    
    // 请求数据加载
    emit requestRowsData(startRow + 1, rowCount); // +1跳过表头
    
    // 更新当前起始行
    m_currentStartRow = startRow;
}
```

#### 2.2 预加载（拖动停止后）
```cpp
void MainWindow::onScrollStopped() {
    m_isScrolling = false;
    
    // 预加载当前区域及前后缓冲区域数据
    preloadBufferedData(m_lastScrollValue);
}

void MainWindow::preloadBufferedData(qint64 centerRow) {
    // 预加载前置缓冲区域
    qint64 preStart = qMax(0LL, centerRow - m_bufferRows);
    qint64 preEnd = centerRow - 1;
    if (preStart <= preEnd) {
        requestPreload(preStart, preEnd - preStart + 1, PRE_BUFFER);
    }
    
    // 预加载后置缓冲区域
    qint64 postStart = centerRow + m_visibleRows;
    qint64 postEnd = qMin(m_totalRows - 1, postStart + m_bufferRows - 1);
    if (postStart <= postEnd) {
        requestPreload(postStart, postEnd - postStart + 1, POST_BUFFER);
    }
}
```

### 3. 缓存管理

#### 3.1 缓存更新
```cpp
void MainWindow::updateCache(const DataBlock& newBlock) {
    // 检查是否已存在相同区域的缓存
    for (auto it = cacheBlocks.begin(); it != cacheBlocks.end(); ++it) {
        if (it->startRow == newBlock.startRow && it->endRow == newBlock.endRow) {
            // 更新现有缓存
            *it = newBlock;
            it->timestamp = QDateTime::currentDateTime();
            it->accessCount++;
            return;
        }
    }
    
    // 添加新缓存
    DataBlock block = newBlock;
    block.timestamp = QDateTime::currentDateTime();
    block.accessCount = 1;
    cacheBlocks.append(block);
    
    // 检查内存使用情况，必要时执行淘汰
    checkMemoryUsage();
}
```

#### 3.2 缓存淘汰策略
```cpp
void MainWindow::evictCache() {
    // 组合LRU和LFU策略进行淘汰
    // 优先淘汰访问次数少且时间久远的数据块
    
    if (cacheBlocks.size() <= 1) return;
    
    // 按访问频率和时间戳排序
    std::sort(cacheBlocks.begin(), cacheBlocks.end(), 
              [](const DataBlock& a, const DataBlock& b) {
                  // 综合考虑访问次数和时间戳
                  QDateTime now = QDateTime::currentDateTime();
                  qint64 timeDiffA = a.timestamp.secsTo(now);
                  qint64 timeDiffB = b.timestamp.secsTo(now);
                  
                  // 归一化评分 (访问次数权重0.7，时间权重0.3)
                  double scoreA = 0.7 * a.accessCount + 0.3 * (1.0 / (1.0 + timeDiffA));
                  double scoreB = 0.7 * b.accessCount + 0.3 * (1.0 / (1.0 + timeDiffB));
                  
                  return scoreA < scoreB; // 分数低的优先淘汰
              });
    
    // 淘汰最低分的缓存块
    cacheBlocks.removeFirst();
}
```

#### 3.3 内存使用控制
```cpp
void MainWindow::checkMemoryUsage() {
    // 估算当前缓存内存使用量
    qint64 memoryUsage = calculateCacheMemoryUsage();
    
    // 如果超过限制，执行缓存淘汰
    while (memoryUsage > m_maxMemoryUsage && !cacheBlocks.isEmpty()) {
        evictCache();
        memoryUsage = calculateCacheMemoryUsage();
    }
}

qint64 MainWindow::calculateCacheMemoryUsage() {
    qint64 totalUsage = 0;
    for (const DataBlock& block : cacheBlocks) {
        // 粗略估算每个数据块的内存使用量
        totalUsage += block.data.size() * block.data.first().size() * sizeof(QString);
    }
    return totalUsage;
}
```

## 用户体验优化

### 1. 视觉反馈
``cpp
void MainWindow::showLoadingIndicator(bool show) {
    if (show) {
        // 显示加载指示器
        statusBar()->showMessage("正在加载数据...");
    } else {
        // 隐藏加载指示器
        QString positionInfo = QString("显示行 %1-%2 (共%3行)")
            .arg(m_currentStartRow + 1)
            .arg(m_currentStartRow + m_tableModel->rowCount())
            .arg(m_totalRows);
        statusBar()->showMessage(positionInfo);
    }
}

void MainWindow::onVerticalScrollBarValueChanged(int value) {
    // 立即提供视觉反馈
    QString positionMsg = QString("位置: 第%1行")
        .arg(value + 1);
    statusBar()->showMessage(positionMsg);
    
    // 改变滚动条颜色表示"处理中"
    QPalette pal = ui->verticalScrollBar->palette();
    pal.setColor(QPalette::Active, QPalette::Highlight, QColor(255, 255, 0, 128)); // 半透明黄色
    ui->verticalScrollBar->setPalette(pal);
    
    // 原有处理逻辑...
}
```

### 2. 响应性优化
1. 使用后台线程执行数据加载操作
2. 实现延迟加载避免频繁IO
3. 提供数据缓存减少重复加载
4. 优化数据结构减少内存占用

## 实现要点

1. **滚动检测**：准确检测用户滚动状态和停止时机
2. **数据分层**：区分即时加载和预加载的数据范围
3. **缓存策略**：实现高效的缓存存储和检索机制
4. **内存控制**：限制缓存大小，防止内存占用过高
5. **线程安全**：确保缓存访问的线程安全性
6. **智能预测**：根据用户行为调整预加载策略

## 与现有架构的集成

### 1. 在MainWindow类中添加必要成员
``cpp
// 在MainWindow.h中添加
private:
    DataCacheManager m_cacheManager;     // 缓存管理器
    QTimer* m_scrollStopTimer;           // 滚动停止检测定时器
    bool m_isScrolling;                  // 是否正在滚动
    qint64 m_lastScrollValue;            // 上次滚动值
    qint64 m_bufferRows;                 // 缓冲行数
    static const int SCROLL_STOP_DELAY = 300; // 滚动停止判定延迟(ms)
```

### 2. 修改滚动条处理逻辑
``cpp
// 在MainWindow构造函数中初始化
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    // ... 其他初始化
    , m_scrollStopTimer(new QTimer(this))
    , m_isScrolling(false)
    , m_lastScrollValue(0)
    , m_bufferRows(200) // 默认缓冲200行
{
    // ... 其他初始化代码
    
    // 设置滚动停止检测定时器
    m_scrollStopTimer->setSingleShot(true);
    connect(m_scrollStopTimer, &QTimer::timeout, this, &MainWindow::onScrollStopped);
    
    // 连接滚动条信号和槽
    connect(ui->verticalScrollBar, &QScrollBar::valueChanged,
            this, &MainWindow::onVerticalScrollBarValueChanged);
}

void MainWindow::onVerticalScrollBarValueChanged(int value) {
    // 立即提供视觉反馈
    QString positionMsg = QString("位置: 第%1行")
        .arg(value + 1);
    statusBar()->showMessage(positionMsg);
    
    // 更新滚动状态
    m_isScrolling = true;
    m_lastScrollValue = value;
    
    // 重启滚动停止检测定时器
    m_scrollStopTimer->start(SCROLL_STOP_DELAY);
    
    // 即时加载当前可视区域数据
    loadVisibleData(value);
}

void MainWindow::onScrollStopped() {
    m_isScrolling = false;
    
    // 预加载缓冲区域数据
    preloadBufferedData(m_lastScrollValue);
    
    // 恢复滚动条正常样式
    ui->verticalScrollBar->setPalette(QPalette());
}
```

## 性能优势

这个方案能带来以下性能优势：

1. **响应速度**：拖动时只加载当前显示区域，响应迅速
2. **用户体验**：停止拖动后预加载数据，后续浏览流畅
3. **资源利用**：合理使用内存缓存，避免重复加载
4. **内存控制**：通过缓存管理和淘汰机制控制内存使用
5. **并发处理**：后台预加载不阻塞主线程

## 扩展性考虑

1. **可配置参数**：
   - 缓冲区域大小
   - 滚动停止检测延迟时间
   - 最大内存使用量

2. **高级特性**：
   - 根据用户行为调整预加载策略
   - 支持磁盘缓存以处理超大数据集
   - 自适应缓冲区域大小调整

3. **与现有功能的兼容性**：
   - 保持现有的异步加载机制
   - 兼容现有的性能监控功能
   - 不影响筛选面板等其他功能

这个方案能够很好地平衡性能、内存使用和用户体验，为用户提供流畅的大型CSV文件浏览体验。



让我为您设计一个完整的 [handleSmallScroll](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/mainwindow.h#L43-L43) 方案，包含滚动条移动、鼠标滑轮和键盘操作的处理，并确保视图与滚动条同步且避免无限循环。

## 方案概述

### 核心思路
1. 统一处理所有滚动操作（滚动条、鼠标滚轮、键盘）
2. 区分小范围滚动和大范围滚动
3. 保持视图与外部滚动条同步
4. 防止信号循环调用

### 实现细节

#### 1. 修改 MainWindow 类
```cpp
// 在 MainWindow 类中添加新成员
private:
    bool m_internalScrollBarChange; // 防止滚动条信号循环调用
    bool m_internalViewScroll;      // 防止视图滚动信号循环调用
    
    // 添加新方法
    void synchronizeScrollBarWithView();  // 同步滚动条与视图
    void synchronizeViewWithScrollBar();  // 同步视图与滚动条
```

#### 2. 处理滚动条变化
```cpp
void MainWindow::onVerticalScrollBarValueChanged(int value)
{
    if (m_internalScrollBarChange) {
        return; // 避免循环调用
    }
    
    qDebug() << "滚动条值变化: value=" << value << ", 当前起始行=" << m_currentStartRow;
    
    // 当滚动条值变化时，同步视图
    synchronizeViewWithScrollBar();
    
    // 启动延迟加载定时器
    m_delayedLoadTimer->start(200); // 200ms延迟
    m_preloadTimer->start(500); // 500ms预加载延迟
}
```

#### 3. 处理视图滚动事件
```cpp
// 在构造函数中连接视图滚动信号
connect(ui->tableView->verticalScrollBar(), &QScrollBar::valueChanged,
        this, &MainWindow::onTableViewScrolled);

void MainWindow::onTableViewScrolled(int value)
{
    if (m_internalViewScroll) {
        return; // 避免循环调用
    }
    
    // 同步外部滚动条与视图
    synchronizeScrollBarWithView();
    
    // 触发延迟加载
    m_delayedLoadTimer->start(200);
    m_preloadTimer->start(500);
}
```

#### 4. 同步方法实现
```cpp
void MainWindow::synchronizeScrollBarWithView()
{
    m_internalScrollBarChange = true;
    
    // 获取视图滚动条的值
    int viewValue = ui->tableView->verticalScrollBar()->value();
    
    // 同步到外部滚动条
    ui->verticalScrollBar->setValue(viewValue);
    
    m_internalScrollBarChange = false;
}

void MainWindow::synchronizeViewWithScrollBar()
{
    m_internalViewScroll = true;
    
    // 获取外部滚动条的值
    int scrollBarValue = ui->verticalScrollBar->value();
    
    // 同步到视图滚动条
    ui->tableView->verticalScrollBar()->setValue(scrollBarValue);
    
    m_internalViewScroll = false;
}
```

#### 5. 小范围滚动处理
```cpp
void MainWindow::handleSmallScroll(qint64 targetPosition)
{
    // 小范围滚动时，调整TableModel中的可视窗口
    qint64 relativePosition = targetPosition - m_tableModel->getFullDataStartRow();
    
    qDebug() << "小范围滚动处理: targetPosition=" << targetPosition 
             << ", fullDataStartRow=" << m_tableModel->getFullDataStartRow()
             << ", relativePosition=" << relativePosition;
    
    // 检查目标位置是否在当前Model数据范围内
    if (relativePosition >= 0 && 
        relativePosition + m_visibleRows <= m_tableModel->getFullDataSize()) {
        // 在范围内，只需调整可视窗口
        m_tableModel->adjustVisibleWindow(relativePosition);
        
        // 更新当前起始行
        m_currentStartRow = targetPosition;
        
        // 同步视图与滚动条
        synchronizeViewWithScrollBar();
        
        qDebug() << "小范围滚动处理完成: 调整可视窗口到" << relativePosition;
    } else {
        // 超出范围，需要加载新数据（降级到大范围滚动处理）
        qDebug() << "小范围滚动超出范围，降级到大范围滚动处理";
        handleLargeScroll(targetPosition);
    }
}
```

#### 6. 键盘事件处理
```cpp
// 在构造函数中启用键盘焦点
ui->tableView->setFocusPolicy(Qt::StrongFocus);
ui->tableView->setFocus();

// 重写键盘事件处理
void MainWindow::keyPressEvent(QKeyEvent *event)
{
    switch (event->key()) {
    case Qt::Key_Up:
    case Qt::Key_Down:
    case Qt::Key_PageUp:
    case Qt::Key_PageDown:
    case Qt::Key_Home:
    case Qt::Key_End:
        // 这些按键会触发视图滚动，不需要特殊处理
        break;
    default:
        QWidget::keyPressEvent(event);
    }
}
```

#### 7. 鼠标滚轮处理
```cpp
// 在构造函数中启用鼠标滚轮事件
ui->tableView->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);

// 重写鼠标滚轮事件处理（如果需要特殊处理）
void MainWindow::wheelEvent(QWheelEvent *event)
{
    // 让QTableView默认处理滚轮事件
    // 这会触发视图滚动条的变化，进而触发我们的同步机制
    QWidget::wheelEvent(event);
}
```

### 完整工作流程

1. **用户操作**（滚动条、鼠标滚轮、键盘）：
   - 触发视图滚动条变化
   - 触发外部滚动条变化

2. **发生异常，可以输入更多信息再让我来回答或重试