# 双策略数据加载与缓存机制

## 1. 概述

本方案旨在实现一个高效的CSV文件查看器，能够流畅处理大型CSV文件的浏览。通过双策略数据加载机制和智能缓存管理，确保用户在滚动浏览时获得流畅的体验。

## 2. 核心设计思想

### 2.1 双策略数据加载
1. **大范围滚动策略**：当用户进行大幅度滚动时，重新加载目标区域的数据
2. **小范围滚动策略**：当用户进行小幅度滚动时，利用已加载的数据窗口进行视图调整

### 2.2 三倍窗口机制
数据模型始终维护三倍于可视区域的数据量，以支持高效的前后滚动：
- 前缓冲区：一倍可视区域数据量
- 可视区域：一倍可视区域数据量
- 后缓冲区：一倍可视区域数据量

### 2.3 智能预加载
当用户停止滚动时，自动预加载当前可视区域前后各一倍可视区域的数据，提升后续浏览体验。

## 3. 已实现功能

### 3.1 大范围数据加载
当检测到大范围滚动时，系统会：
1. 清空当前数据窗口
2. 计算目标区域（三倍于可视区域）
3. 请求加载目标区域数据
4. 更新数据模型和视图

### 3.2 智能预加载
当用户停止滚动500ms后：
1. 计算前置预加载区域（当前区域前一倍可视区域）
2. 计算后置预加载区域（当前区域后一倍可视区域）
3. 并行请求这两个区域的数据
4. 将预加载数据整合到现有数据窗口中

## 4. 待实现功能：小范围滚动处理

### 4.1 需求分析
用户在以下场景中需要小范围滚动处理：
1. 使用鼠标滚轮在TableView中滚动
2. 使用键盘方向键在TableView中滚动
3. 小幅度拖动外部滚动条

### 4.2 设计方案

#### 4.2.1 同步机制
实现滚动条、TableView和数据模型之间的双向同步：

```cpp
class MainWindow {
private:
    bool m_internalScrollBarChange; // 防止滚动条信号循环调用
    
public:
    // 同步滚动条和TableView位置
    void syncScrollBarWithTableView(int tableViewRow);
    void syncTableViewWithScrollBar(int scrollBarValue);
};
```

#### 4.2.2 鼠标滚轮处理
```cpp
// 在TableView中处理鼠标滚轮事件
void MainWindow::handleTableViewWheelEvent(QWheelEvent* event) {
    // 计算滚动行数
    int delta = event->angleDelta().y();
    int scrollRows = -delta / 120; // 通常每120个单位滚动1行
    
    // 计算新的滚动条值
    int newScrollBarValue = ui->verticalScrollBar->value() + scrollRows;
    newScrollBarValue = qBound(0, newScrollBarValue, 
                              ui->verticalScrollBar->maximum());
    
    // 更新滚动条值（会触发onVerticalScrollBarValueChanged）
    m_internalScrollBarChange = true;
    ui->verticalScrollBar->setValue(newScrollBarValue);
    
    // 同步TableView位置
    syncTableViewWithScrollBar(newScrollBarValue);
}
```

#### 4.2.3 键盘操作处理
```cpp
// 处理键盘方向键事件
void MainWindow::handleKeyPressEvent(QKeyEvent* event) {
    int currentScrollBarValue = ui->verticalScrollBar->value();
    int newScrollBarValue = currentScrollBarValue;
    
    switch (event->key()) {
    case Qt::Key_Up:
        newScrollBarValue = qMax(0, currentScrollBarValue - 1);
        break;
    case Qt::Key_Down:
        newScrollBarValue = qMin(ui->verticalScrollBar->maximum(), 
                                currentScrollBarValue + 1);
        break;
    case Qt::Key_PageUp:
        newScrollBarValue = qMax(0, currentScrollBarValue - m_visibleRows);
        break;
    case Qt::Key_PageDown:
        newScrollBarValue = qMin(ui->verticalScrollBar->maximum(), 
                                currentScrollBarValue + m_visibleRows);
        break;
    case Qt::Key_Home:
        newScrollBarValue = 0;
        break;
    case Qt::Key_End:
        newScrollBarValue = ui->verticalScrollBar->maximum();
        break;
    default:
        // 其他按键不处理
        return;
    }
    
    // 更新滚动条值
    if (newScrollBarValue != currentScrollBarValue) {
        m_internalScrollBarChange = true;
        ui->verticalScrollBar->setValue(newScrollBarValue);
        
        // 同步TableView位置
        syncTableViewWithScrollBar(newScrollBarValue);
    }
}
```

#### 4.2.4 小范围滚动核心实现
```cpp
void MainWindow::handleSmallScroll(qint64 targetPosition) {
    // 计算相对位置
    qint64 relativePosition = targetPosition - m_tableModel->getFullDataStartRow();
    
    // 检查目标位置是否在当前Model数据范围内
    if (relativePosition >= 0 && 
        relativePosition + m_visibleRows <= m_tableModel->getFullDataSize()) {
        // 在范围内，只需调整可视窗口
        m_tableModel->adjustVisibleWindow(relativePosition);
        
        // 更新当前起始行
        m_currentStartRow = targetPosition;
        
        // 同步滚动条和TableView
        syncScrollBarWithTableView(targetPosition);
    } else {
        // 超出范围，需要加载新数据（降级到大范围滚动处理）
        handleLargeScroll(targetPosition);
    }
}

void MainWindow::syncScrollBarWithTableView(int tableViewRow) {
    // 防止循环调用
    if (m_internalScrollBarChange) {
        return;
    }
    
    // 计算滚动条应该的值
    int scrollBarValue = m_tableModel->getFullDataStartRow() + tableViewRow;
    
    // 更新滚动条值
    m_internalScrollBarChange = true;
    ui->verticalScrollBar->setValue(scrollBarValue);
}
```

### 4.3 循环调用防护机制

#### 4.3.1 标志位机制
```cpp
// 在滚动相关操作前设置标志位
m_internalScrollBarChange = true;

// 在滚动处理函数开始处检查标志位
if (m_internalScrollBarChange) {
    m_internalScrollBarChange = false;
    return;
}
```

#### 4.3.2 信号阻塞机制
```cpp
// 临时阻塞信号
ui->verticalScrollBar->blockSignals(true);
ui->verticalScrollBar->setValue(newValue);
ui->verticalScrollBar->blockSignals(false);
```

### 4.4 性能优化

#### 4.4.1 视图更新优化
```cpp
// 使用dataChanged而不是重置整个模型
void TableModel::adjustVisibleWindow(qint64 relativeStartRow) {
    if (relativeStartRow >= 0 && 
        relativeStartRow + m_visibleRows <= m_fullData.size()) {
        m_visibleStartRow = relativeStartRow;
        // 只通知视图更新，不重置整个模型
        emit dataChanged(
            index(0, 0), 
            index(m_visibleRows - 1, columnCount() - 1)
        );
    }
}
```

## 5. 数据模型增强

### 5.1 现有功能
TableModel已实现三倍窗口机制，包含以下方法：
- [setFullData()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/tablemodel.h#L27-L27)：设置完整数据（三倍大小）
- [adjustVisibleWindow()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/tablemodel.h#L28-L28)：调整可视窗口
- [getFullDataStartRow()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/tablemodel.h#L29-L29)：获取完整数据的起始行号
- [getFullDataSize()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/tablemodel.h#L30-L30)：获取完整数据的大小

### 5.2 预加载数据整合
已实现将预加载数据整合到现有数据窗口中：
- [prependPreloadedData()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/tablemodel.h#L35-L35)：在前面添加预加载数据
- [appendPreloadedData()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/tablemodel.h#L36-L36)：在后面添加预加载数据
- [maintainTripleWindowSize()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/tablemodel.h#L39-L39)：维持三倍窗口大小

## 6. 滚动类型检测

通过比较滚动前后的距离判断滚动类型：
```cpp
ScrollType MainWindow::detectScrollType(qint64 oldPosition, qint64 newPosition) {
    // 根据滚动距离判断是大范围还是小范围滚动
    qint64 distance = qAbs(newPosition - oldPosition);
    
    // 如果滚动距离超过可视区域的一半，则认为是大范围滚动
    // 否则为小范围滚动
    if (distance > m_visibleRows / 2) {
        return LARGE_SCROLL;
    } else {
        return SMALL_SCROLL;
    }
}
```

## 7. 动态计算可视行数方案

### 7.1 问题分析
当前实现中将可视行数固定为100行，这会带来以下问题：
1. 窗口大小变化时无法自适应
2. 行高变化时无法自适应
3. 可能导致TableView自身出现滚动条
4. 用户体验不佳

### 7.2 解决方案

#### 7.2.1 动态计算可视行数
```cpp
void MainWindow::updateVisibleRows() {
    // 获取TableView的可视区域高度
    int viewportHeight = ui->tableView->viewport()->height();
    
    // 获取单行高度
    int rowHeight = ui->tableView->rowHeight(0);
    if (rowHeight <= 0) {
        // 如果无法获取有效行高，使用默认值
        rowHeight = 20; // 假设默认行高为20像素
    }
    
    // 计算可视行数
    int visibleRows = viewportHeight / rowHeight;
    
    // 确保至少显示1行
    visibleRows = qMax(1, visibleRows);
    
    // 更新可视行数
    m_visibleRows = visibleRows;
    
    qDebug() << "更新可视行数: viewportHeight=" << viewportHeight 
             << ", rowHeight=" << rowHeight 
             << ", visibleRows=" << visibleRows;
}

// 在窗口大小改变时调用
void MainWindow::resizeEvent(QResizeEvent* event) {
    QMainWindow::resizeEvent(event);
    
    // 更新可视行数
    updateVisibleRows();
    
    // 更新滚动条范围
    updateScrollBarRange();
    
    // 重新加载当前可视区域数据以适应新大小
    handleLargeScroll(ui->verticalScrollBar->value());
}
```

#### 7.2.2 确保TableView不出现滚动条
```cpp
// 在构造函数中确保TableView不显示垂直滚动条
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    // ... 其他初始化
{
    // ... 其他代码
    
    // 确保禁用TableView自带的垂直滚动条
    ui->tableView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    
    // ... 其他代码
}

// 在数据加载完成后确保TableView高度适应数据
void MainWindow::onRowsDataReceived(const struct CsvRowData &rowData, qint64 startRow) {
    // ... 其他代码
    
    // 使用数据窗口方式更新表格模型中的数据（3倍于可视区域）
    m_tableModel->setFullData(rowData.rows, startRow);
    
    // 强制刷新视图
    ui->tableView->viewport()->update();
    
    // 确保滚动到正确位置
    if (rowData.rows.size() > 0) {
        QModelIndex firstIndex = m_tableModel->index(0, 0);
        ui->tableView->scrollTo(firstIndex, QAbstractItemView::PositionAtTop);
    }
    
    // ... 其他代码
}
```

#### 7.2.3 处理边界情况
```cpp
// 在大范围滚动处理中考虑动态可视行数
void MainWindow::handleLargeScroll(qint64 targetPosition) {
    // 1. 清除当前显示的数据，但保留表头
    m_tableModel->clearDataOnly(); // 只清空数据部分
    
    // 2. 更新可视行数（以防窗口大小已改变）
    updateVisibleRows();
    
    // 3. 计算需要加载的数据范围（3倍于可视区域）
    qint64 startRow = targetPosition;
    qint64 rowCount = m_visibleRows * 3;
    
    qDebug() << "大范围滚动处理: 起始行=" << startRow + 1 
             << ", 行数=" << rowCount 
             << ", 可视行数=" << m_visibleRows;
    
    // 4. 请求数据加载
    emit requestRowsData(startRow + 1, rowCount); // +1是因为跳过表头
    
    // 5. 更新当前起始行
    m_currentStartRow = targetPosition;
}

// 在预加载处理中考虑动态可视行数
void MainWindow::preloadData(qint64 centerRow) {
    // 更新可视行数
    updateVisibleRows();
    
    // 计算预加载范围：前后各m_visibleRows行
    qint64 preStartRow = qMax(0LL, centerRow - m_visibleRows);
    qint64 postEndRow = qMin(m_totalRows - 1, centerRow + 2 * m_visibleRows - 1);
    
    qDebug() << "预加载数据: 中心行=" << centerRow 
             << ", 前置范围=[" << preStartRow << "," << (centerRow-1) << "]"
             << ", 后置范围=[" << (centerRow + m_visibleRows) << "," << postEndRow << "]"
             << ", 可视行数=" << m_visibleRows;
    
    // 请求预加载前置数据
    if (preStartRow < centerRow) {
        qint64 rowCount = centerRow - preStartRow;
        emit requestPreloadData(preStartRow + 1, rowCount); // +1跳过表头
        qDebug() << "请求前置预加载数据: 起始行=" << (preStartRow + 1) << ", 行数=" << rowCount;
    }
    
    // 请求预加载后置数据
    qint64 postStartRow = centerRow + m_visibleRows;
    if (postStartRow <= postEndRow) {
        qint64 rowCount = postEndRow - postStartRow + 1;
        emit requestPreloadData(postStartRow + 1, rowCount); // +1跳过表头
        qDebug() << "请求后置预加载数据: 起始行=" << (postStartRow + 1) << ", 行数=" << rowCount;
    }
}
```

### 7.3 实现要点

1. **动态计算**：根据TableView的可视区域高度和行高动态计算可视行数
2. **窗口大小适应**：在窗口大小改变时重新计算可视行数并更新显示
3. **滚动条同步**：确保外部滚动条范围与动态可视行数同步
4. **边界处理**：在各种操作中考虑动态可视行数的变化
5. **性能优化**：避免频繁计算可视行数，只在必要时更新

## 8. 完整滚动处理流程

### 8.1 用户操作触发
1. 用户通过滚动条、鼠标滚轮或键盘操作触发滚动
2. [onVerticalScrollBarValueChanged()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/mainwindow.h#L34-L34)槽函数被调用

### 8.2 延迟处理
1. 启动200ms延迟加载定时器
2. 启动500ms预加载定时器

### 8.3 滚动处理
1. 200ms后，[onDelayedLoad()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/mainwindow.h#L36-L36)被调用
2. 检测滚动类型（大范围或小范围）
3. 调用相应处理函数（[handleLargeScroll()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/mainwindow.h#L43-L43)或[handleSmallScroll()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/mainwindow.h#L44-L44)）

### 8.4 预加载处理
1. 500ms后，[onPreloadTimeout()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/mainwindow.h#L35-L35)被调用
2. [preloadData()](file:///C:/Users/Guo/Desktop/code/Qt/my_csv_viewer/mainwindow.h#L45-L45)计算预加载区域
3. 请求预加载数据
4. 数据返回后整合到现有数据窗口

## 9. 性能优势

1. **响应速度快**：小范围滚动无需重新加载数据
2. **内存效率高**：维持固定大小的数据窗口
3. **用户体验好**：预加载机制提升后续浏览流畅度
4. **自适应性强**：动态计算可视行数适应窗口变化
5. **资源占用低**：避免不必要的数据加载和内存占用